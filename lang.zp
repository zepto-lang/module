(let ()
  (define (def-fun env exp)
    (cond
      ((symbol? exp) (cons (symbol->string exp) `(,(eval exp env))))
      ((and (eq? (length exp) 3) (eq? :as (cadr exp)))
        (cons (symbol->string (caddr exp)) `(,(eval (car exp) env))))
      (else
        (error:from-string (++ "Unknown form in export: " (->string exp))))))

  (define (parse-mod str)
    (let* ((lines   (string:split str "\n"))
           (name    (string:trim (string:substitute (car lines) "#lang module" "")))
           (code    (string:trim (string:join (cdr lines) "\n")))
           (code    (cdr (string:parse (++ "(begin " code ")"))))
           (exports (filter ($ (eq? (car %) 'export)) code))
           (exports (reduce ++ [] (map cdr exports)))
           (code    (filter ($ (not (eq? (car %) 'export))) code))
           (env     (current-env))
           (def-fun (curry def-fun env)))
      (hash:kv-map ($ (eval `(define ,(string->symbol (car %)) ,(cadr %)) env))
                   (get-from *modules* name #{}))
      (map ($ (eval % env)) (macro-expand code))
      (if (in? *modules* name)
        `((hash:update! *modules* ,name
          ,($ (hash:merge % (make-hash (map def-fun exports))))))
        `((hash:set! *modules* ,name
            ,(make-hash (map def-fun exports)))))))
  (zepto:implements-lang parse-mod "module"))
